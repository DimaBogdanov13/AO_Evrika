# AO_Evrika
## Задание 1.1. Создать графическое приложение с использование библиотека Qt, содержащее две пустые формы, содержащие кнопку строго по центру:
•	первая форма – главное окно. При нажатии на кнопку открывается вторая форма. <br/>
•	вторая форма – диалог. При нажатии на кнопку создается текстовый файл, содержащий строку текста «Миру мир!» и завершается работа приложения.
<br/> (Путь до текстового файла редактируется в классе Backend)

## 1.2 Что происходит при вызове виртуальной функции в конструкторе базового класса?
Проверяется есть ли переопределение данной функции в классе (override) если да, то вызывается эта переопределённая функция если нет, то вызывается реализация из класса от которого мы пронаследовались.  <br/>

## 1.3 В чем разница между struct и class? 
1) В class поля и методы по умолчанию private, а в struct public.
2) class только в С++, struct в С++ и С.

## 1.4 В чем отличие malloc от new?
malloc() - функция языка С, в аргументе указывается размер выделяемой памяти.  <br/>
new выделяет вызывает память под конкретную переменную и вызывает конструктор если он есть. Работает только в C++. <br/>
new/delete, malloc/free <br/>

## 1.5 В чем различия между delete и delete[]?
delete для указателя, delete[] для динамического массива.

## 1.6 В чем отличие std::list<T> от std::vector<T>?
std::vector - динамический массив. <br/>
std::list - двусвязный список. <br/>

## 1.7 Для чего нужен тип std::auto_ptr<T>?
Умный указатель, в деструкторе которого выполняется delete, чтобы не было утечки памяти. Сам тип auto_ptr уже устаревший.

## 1.8 QString a = “Вася”; QString b; b = a; Происходит ли копирование данных? 
Да, происходит.

## 1.9 const char* a = “Вася”; QString b; b = a; Происходит ли копирование данных? Можно ли так вообще делать и почему?
Да, происходит, потому что у QString есть конструктор QString::QString(const char *str). <br/>

## 1.10 Корректно ли написан код? 
QStringList list; <br/>
list << “Вася” << “Петя” << “Коля”; <br/>
QList <const char*> clist; <br/>
QString str; <br/>

foreach (str, list) <br/>
{ <br/>
	const char* tmp = str.toLocal8Bit().constData(); <br/>
clist.push_back(tmp); <br/>
} <br/>
func_work_with_const_char_list (clist); <br/>
Да, код скомпилируется (если есть реализация функции func_work_with_const_char_list (clist)).

## 1.11 Чем отличается процесс от потока? Какие вы знаете методы синхронизации потоков? Что такое thread safe класс?
Процесс — экземпляр программы во время выполнения <br/>
Поток — это базовая единица, которой операционная система выделяет процессорное время  <br/>
Один или несколько потоков выполняются в контексте процесса.   <br/>

Существует несколько методов синхронизации потоков:  <br/>
Mutex <br/>
Переменные состояния <br/>
Семафоры <br/>

thread safe класс - потокобезопасный класс, когда класс тщательно синхронизирован для защиты данных.


## 1.12 Что такое сложность алгоритма и в чем она измеряется? Оцените сложность операции вставки и поиска для следующих типов контейнеров, почему она именно такая:
std::vector <br/>
std::list <br/>
std::map <br/>
сортированный std::list <br/>
сортированный std::vector <br/>

Сложность алгоритма - это количественная характеристика, которая говорит о том, сколько времени, либо какой объём памяти потребуется для выполнения алгоритма.  <br/>
std::vector вставка O(n), поиск  O(n) (худший случай)   <br/>
std::list вставка O(1), поиск O(n) (худший случай) <br/>
std::map <br/> вставка O(log n), поиск O(log n)  <br/>
сортированный std::list поиск O(log n) еслис использовать бинарный поиск <br/>
сортированный std::vector поиск  O(log n) еслис использовать бинарный поиск <br/> 


## 1.13 Напишите запрос SQL, который выведет родителей, имеющих не более 2 иждивенцев. 
Таблица: Родители <br/>
| Id родителя | ФИО    |  
| :---:   | :---: |
| 1 | Иванов А.В.  | 
| 2 | Петрова Е.К.  | 
| 3 | Сидорова С.С.  | 

Таблица: Дети <br/>
| Id ребенка | Id родителя    | Имя    |
| :---:   | :---: | :---: |
| 1 | 1  | Катя  | 
| 2 | 1  | Петя  |
| 3 | 1  | Толик |
| 4 | 2  | Виктор |
| 5 | 2  | Лена |
| 6 | 3  | Маша |

SELECT PARENTS.FULLNAME  <br/>
FROM PARENTS, KIDS  <br/>

WHERE PARENTS.ID == KIDS.ID_PARENT   <br/> 

GROUP BY KIDS.ID_PARENT    <br/>
HAVING COUNT(*)  <= 2  <br/>

## 1.14 Какое значение получит переменная len?
QString str = “Вася”;  <br/>
int len = strlen( str.toLocal8Bit().data() ); <br/>

QByteArray byte_array = str.toLocal8Bit().data(); //  str.toLocal8Bit().data() - это массив байтов <br/>
qDebug() << "byte_array = " + byte_array; // выведем его в консоль и получим \xD0\x92\xD0\xB0\xD1\x81\xD1\x8F <br/>
qDebug() << "len = " + QString::number(strlen(byte_array)); // strlen() - считает количество символов в строке у нас 8 символов разделённых \ <br/>
Ответ: 8






